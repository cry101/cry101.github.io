<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Cary"><meta name="keywords" content="个人博客"><meta name="description" conauthortent="若尧的博客"><link rel="alternative" href="/atom.xml" title="若尧" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>react和vue的比较 - 若尧</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><div class="hide" id="particles-oli-wrapper"></div><header class="head"><h1 class="head-title u-fl"><a href="/">若尧</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">目录</a></li><li class="head-nav__item"><a class="head-nav__link" href="/about">关于</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-03-26T09:27:45.000Z">三月 26, 2018</time><h1 class="post__title"><a href="/2018/03/26/react-vue/">react和vue的比较</a></h1><div class="post__main echo"><h3 id="1-相比较jquery"><a href="#1-相比较jquery" class="headerlink" title="1.相比较jquery"></a>1.相比较jquery</h3><p>jquery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，<br>其实和原生的javascript的区别只在于可以更方便的选取和操作DOM对象,还有jquery更好的封装性，兼容性。<br>比如说添加个事件监听：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果用js需要做兼容</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.addEventListener != <span class="string">"undefined"</span>) &#123; </span><br><span class="line">	<span class="built_in">document</span>.addEventListener(<span class="string">"mousedown"</span>,XXX,<span class="literal">true</span>); <span class="comment">//google</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="built_in">document</span>.attachEvent(<span class="string">"onmousedown"</span>,XXX); <span class="comment">//IE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用jquery纯dom操作，太多的浏览器事件会导致监听混乱/项目不好维护/占用很大的内存。<br>而且它在客观上没有推动开发者了解和使用抽象程度更高的领域。<br>包括但不限于数据结构，设计模式，数据流，抽象数据类型，抽象过程等。</p>
<p>而Vue.js 专注于 MVVM 模型的 ViewModel 层，通过数据驱动视图。<br>模块化的开发，组件式的思想，更加高效，更加友好<br>Vue已经解决了之前jQuery很多痛点：<br>1.无需担心DOM回调，这种复杂性已经被封装。Vue的生命周期挂钩将允许更精确的控制，如果它需要。<br>2.在数据属性counter和它渲染输出DOM节点之间有一个明显的之间的链接。<br>3.我们没有模棱两可的API方法需要查找或记住。不同的功能被很好的组织和分层在Vue构造函数对象中，<br>或能通过指令直接应用到模板中的DOM节点，这些指令提供更多的易于理解的上下文。</p>
<p>比如 React ，一开始就必须接受 view = f (state) 的思想。<br>几乎稍微深入的使用，就会开始思考数据的互传，进而是单向数据流，最后深入到各种数据流方案的讨论和选择。</p>
<p>持续集成：项目上线并不是完事大吉了，后续我们还要面临需求迭代、bug修复、合作甚至交接等其他问题。<br>因此一个可持续集成的工程化项目架构就显得尤为重要，项目架构和技术栈的选择往往是密不可分的，但二者并不存在必然关系。<br>比如在没有ES6的年代，我们依然可以使用RequireJS或者seajs来达到js的模块化，<br>没有webpack，我们还可以依靠Grunt或者gulp来构建我们的项目。</p>
<h3 id="2-vue和react的优化"><a href="#2-vue和react的优化" class="headerlink" title="2.vue和react的优化"></a>2.vue和react的优化</h3><p>React 的 Virtual DOM 也不是不需要优化的。<br>复杂的应用里你有两个选择：</p>
<ol>
<li>手动添加 shouldComponentUpdate 来避免不需要的 vdom re-render；</li>
<li>Components 尽可能都用 pureRenderMixin，然后采用 Flux 结构 + Immutable.js。</li>
</ol>
<p>Vue采用依赖追踪，默认就是优化状态，通过Object.defineProperty的getter/setter来追踪数据，改了多少数据，就触发多少更新。</p>
<h3 id="3-开发风格不同"><a href="#3-开发风格不同" class="headerlink" title="3.开发风格不同"></a>3.开发风格不同</h3><p>react采用jsx语法 + inline style，把html和css整合进javascript，<br>在逻辑表达上比模版的清晰，但是复杂逻辑很容易写出凌乱的render函数。</p>
<p>vue采用单文件.vue的模版语法，还是熟悉的html，js，css，且方便使用sass/less。</p>
<h3 id="4-数据流不同"><a href="#4-数据流不同" class="headerlink" title="4.数据流不同"></a>4.数据流不同</h3><p>react采用单向数据流，所有state的修改都要通过setState方法，<br>在执行setState的时候，react不是立即更新state，只是把新的state存到一个队列batchUpdate，<br>然后再批处理，其中会经过shouldComponentUpdate来判断是否重新渲染，<br>如果是，react会进行state合并，生成新的state和props，重新render视图；<br>如果不是，react仍然会更新state，但是不会再render。<br>相当于于把setState看作是重新render的一次请求而不是立即更新的指令。</p>
<p>vue采用双向数据流，可以随意修改state，但有些限制。<br>vue的限制：（需要使用Vue.set(object, key, value)方法）<br>（1）不能检测到对象属性的添加和删除<br>（2）不能检测通过索引设置数组的值<br>（3）不能检测直接修改数组的长度 （用splice方法替代）</p>
<h3 id="5-原理不同"><a href="#5-原理不同" class="headerlink" title="5.原理不同"></a>5.原理不同</h3><p>react把每个组件当成一个状态机，组件内部通过state来维护组件状态的变化，<br>当状态改变的时候，通过虚拟dom来增量并且高效的更新真是dom。</p>
<p>vue通过Object.defineProperty的getter/setter来追踪数据,每个组件实例都有watcher，<br>当依赖项的setter被调用时，会通知watcher重新计算，致使组件更新。</p>
<h3 id="6-使用场景不同"><a href="#6-使用场景不同" class="headerlink" title="6.使用场景不同"></a>6.使用场景不同</h3><p>react的生态系统要大于vue，适合大规模多人协作的复杂项目。<br>vue使用在小项目上会更加灵活，简单。</p>
<h3 id="7-redux和vuex"><a href="#7-redux和vuex" class="headerlink" title="7.redux和vuex"></a>7.redux和vuex</h3><p>redux数据流的顺序是：<br>view层调用store.dispatch发起action<br>-&gt; store接收action（action传入reducer，reducer返回一个新的state）<br>-&gt; 通知store.subscribe订阅的重新渲染函数</p>
<p>vuex根据vue的特性改进了redux，以mutations取代reducer，只需在mutation里改变state的值，也无需订阅重新渲染函数<br>vuex数据流的顺序：<br>view层调用store.commit提交对应的请求到store中对应的mutation<br>-&gt; store改变（vue检测数据变化自动渲染）</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/react/">react</a></li><li class="post__tag__item"><a class="post__tag__link" href="/tags/vue/">vue</a></li><li class="post__tag__item"><a class="post__tag__link" href="/tags/jquery/">jquery</a></li></ul></footer></article><link rel="stylesheet" href="/css/menu.css"><script src="/js/jquery.autoMenu.js"></script><div class="autoMenu" id="autoMenu" data-autoMenu></div><section class="reward"> <a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechatImage.jpg" title="微信"><img src="/img/alipayImage.jpg" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 Cary</div></footer><!--include ../plugins/google.pug--><script src="/js/particles.min.js"></script><script src="/js/particles.other.js"></script><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>